# 1.2.1 관심사의 분리

객체지향의 세계에서는 모든 것이 변한다.
여기서 변화란 값(혹은 데이터)이 변하는 것이 아니다.
오브젝트 설계와 이를 구현한 코드가 변한다는 것이다.

소프트웨어 개발에서 끝이란 개념은 없다.
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변한다.
더이상 사용되지 않아 폐기처분될 때까 돼야 변화는 중단된다.


개발자가 객체지향 설계를 할때 가장 염두해둬야 할 것이 바로 '미래의 변화를 어떻게 대비할 것인가?' 이다.
(거대한 작업에 대한 부담, 변경에 따른 스트레스, 고객과 개발팀 간의 내적갈등 등...)

객체지향 --> 실세계에 가깝게 모델링을 기반으로 코드화 시킬 수 있음 (정설)
        
        But 더 큰 의미는 따로 있으니...
        * 가상의 추상세계 자체를 효과적으로 구성하고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있음

변화에 대비하려면 해결책은? 
    변화의 폭을 최소한으로 줄인다!
        똑같은 기능 변경 사항을 얘기했을때, 
        A 개발자는 단지 몇 줄의 코드만 수정한다. 테스트 결과도 좋음 (5분이 채 안걸림)
        B 개발자는 여러 코드를 수정해야 하고, 테스트의 결과도 장담할 수 없음 (5시간이 넘게 걸림)

        과연 어떤 개발자가 미래의 문제에 더 잘 대비했는가? 당연히 A

변경이 일어날 때 작업을 최소화하기 위해서는...? 
    *분리와 확장*을 고려한 설계를 하면 된다.

분리 --> "모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다."
        But.. 이에 따른 작업은 한 곳에 집중되지 않는 경우가 부지기수..
            (DB 암호를 변경하기 위해 수백 개의 DAO 클래스를 수정해야 한다면..?,
            트랜잭션 기술을 다른것으로 바꿨다고 비즈니스 로직이 담긴 코드의 구조를 변경해야 한다면..?
            다른 개발자의 코드 수정으로 내 클래스의 코드 또한 수정해야 한다면..?) ==> 여간 골치아픈 일이 아닐 수 없다.

        우리가 준비해야 할 것은 "한 가지 관심이 한 군데 집중"되게 하는 것이다.
        (관심 있는것끼리는 모으고, 아닌것은 분리한다!) ==> 관심사의 분리 (Separation of Concerns)

        관심이 같은 것끼리 --> 하나의 객체, 혹은 친한 객체로 
        관심이 다른 것들  ---> 서로 영향을 주지 않도록 분리 

처음에는 한 곳에 몰아놓는게 더 쉽다.
하지만 처음 뿐이고, 조금만 규모가 커지면 생산성의 저하가 눈에 띄게 보인다.
분리하는 이유는 효과적으로 집중할 수 있게하기 위함이다.


# 1.2.2 커넥션 만들기의 추출
기존 UserDao를 살펴보면 add() 메소드에서 적어도 세 가지의 관심사항을 발견할 수 있다.

1. DB와 연결을 위한 커넥션 가져오기
2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하기
    (+ 파라미터 바인딩하기)
3. Statement, Connection 오브젝트를 닫아 공유 리소스를 반환하기


가장 먼저 해야할 일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다.
중복된 DB 연결 코드를 getConnection() 이라는 독립적인 메소드로 만들어준다.
--------------------------------------------------------------------------------------------
public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
    // DB 연결 기능이 필요하면 getConnection() 을 이용한다.
    Connection c = getConnection(); 
    ...
}

// 중복된 코드를 독립적인 메소드로 만들어서 중복을 제거 하였다.
private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection(
        "jdbc:mysql://localhost/springbook", "spring", "book");
    return c;
}
--------------------------------------------------------------------------------------------
만약 add, get 같은 메소드가 2000개가 넘는다고 상상해보자. 
DB 연결 관련해서 코드 수정이 이뤄진다면 (DB 종류 변경, URL 변경 등..) getConnection 부분만 수정하면 된다.
즉, 관심사를 한 곳으로 분리해(집중해) 놓았기 때문에 해당 부분만 고치면 된다.
관심이 다른 코드가 있는 메소드에 영향을 주지 않을뿐더러, 독립적으로 존재하여 수정도 간단해졌다.

기능이 추가되거나 바뀐것은 없지만 UserDao는 이전보다 훨씬 깔끔해졌고 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 되었다.
이런 작업을 리팩토링(refactoring)이라고 한다. 
중복된 코드를 뽑아내는 기법을 리팩토링에서는 메소드 추출(Extracting Method) 기법이라고 한다.

## 리팩토링
    리펙토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
    리팩토링을 하면 코드 내부 설계가 개선되어 코드를 이해하기 더 편해지고, 변화에 효율적으로 대응할 수 있다.
    결국 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수가 용이해지고, 견고하면서 유연한 제품을 개발할 수 있게 된다.

    리팩토링이 필요한(절실한) 코드의 특징을 나쁜냄새(bad smell)라고 부르기도 한다. 중복된 코드는 나쁜냄새 유형 중 하나이다.
    나쁜냄새가 풍기는 코드는 리팩토링 기법을 이용해 적절히 개선시켜야 한다.

    리팩토링은 개발자가 직관적으로 수행할 수 있지만, 본격적으로 적용하기 위해서는 학습과 훈련이 필요하다.
    나쁜 냄새에는 어떤 종류가 있고, 그에 따른 적절한 리팩토링 기법은 무엇이 있는지 공부하면 도움이 된다.
    (추천도서 - [리팩토링] 마틴 파울러, 켄트 백 공저)


# 1.2.3 DB 커넥션 만들기의 독립 
 