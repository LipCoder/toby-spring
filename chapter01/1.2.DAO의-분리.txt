# 1.2.1 관심사의 분리

객체지향의 세계에서는 모든 것이 변한다.
여기서 변화란 값(혹은 데이터)이 변하는 것이 아니다.
오브젝트 설계와 이를 구현한 코드가 변한다는 것이다.

소프트웨어 개발에서 끝이란 개념은 없다.
사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변한다.
더이상 사용되지 않아 폐기처분될때까지는 돼야 변화는 중단된다.


개발자가 객체지향 설계를 할때 가장 염두해둬야 할 것이 바로 '미래의 변화를 어떻게 대비할 것인가?' 이다.
(거대한 작업에 대한 부담, 변경에 따른 스트레스, 고객과 개발팀 간의 내적갈등 등...)

객체지향 --> 실세계에 가깝게 모델링을 기반으로 코드화 시킬 수 있음 (정설)
        
        But 더 큰 의미는 따로 있으니...
        * 가상의 추상세계 자체를 효과적으로 구성하고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있음

변화에 대비하려면 해결책은? 
    변화의 폭을 최소한으로 줄인다!
        똑같은 기능 변경 사항을 얘기했을때, 
        A 개발자는 단지 몇 줄의 코드만 수정한다. 테스트 결과도 좋음 (5분이 채 안걸림)
        B 개발자는 여러 코드를 수정해야 하고, 테스트의 결과도 장담할 수 없음 (5시간이 넘게 걸림)

        과연 어떤 개발자가 미래의 문제에 더 잘 대비했는가? 당연히 A

변경이 일어날 때 작업을 최소화하기 위해서는...? 
    *분리와 확장*을 고려한 설계를 하면 된다.

분리 --> "모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다."
        But.. 이에 따른 작업은 한 곳에 집중되지 않는 경우가 부지기수..
            (DB 암호를 변경하기 위해 수백 개의 DAO 클래스를 수정해야 한다면..?,
            트랜잭션 기술을 다른것으로 바꿨다고 비즈니스 로직이 담긴 코드의 구조를 변경해야 한다면..?
            다른 개발자의 코드 수정으로 내 클래스의 코드 또한 수정해야 한다면..?) ==> 여간 골치아픈 일이 아닐 수 없다.

        우리가 준비해야 할 것은 "한 가지 관심이 한 군데 집중"되게 하는 것이다.
        (관심 있는것끼리는 모으고, 아닌것은 분리한다!) ==> 관심사의 분리 (Separation of Concerns)

        관심이 같은 것끼리 --> 하나의 객체, 혹은 친한 객체로 
        관심이 다른 것들  ---> 서로 영향을 주지 않도록 분리 

처음에는 한 곳에 몰아놓는게 더 쉽다.
하지만 처음 뿐이고, 조금만 규모가 커지면 생산성의 저하가 눈에 띄게 보인다.
분리하는 이유는 효과적으로 집중할 수 있게하기 위함이다.


# 1.2.2 커넥션 만들기의 추출
기존 UserDao를 살펴보면 add() 메소드에서 적어도 세 가지의 관심사항을 발견할 수 있다.

1. DB와 연결을 위한 커넥션 가져오기
2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하기
    (+ 파라미터 바인딩하기)
3. Statement, Connection 오브젝트를 닫아 공유 리소스를 반환하기


가장 먼저 해야할 일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다.
중복된 DB 연결 코드를 getConnection() 이라는 독립적인 메소드로 만들어준다.

--------------------------------------------------------------------------------------------
public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
    // DB 연결 기능이 필요하면 getConnection() 을 이용한다.
    Connection c = getConnection(); 
    ...
}

// 중복된 코드를 독립적인 메소드로 만들어서 중복을 제거 하였다.
private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection(
        "jdbc:mysql://localhost/springbook", "spring", "book");
    return c;
}
--------------------------------------------------------------------------------------------

만약 add, get 같은 메소드가 2000개가 넘는다고 상상해보자. 
DB 연결 관련해서 코드 수정이 이뤄진다면 (DB 종류 변경, URL 변경 등..) getConnection 부분만 수정하면 된다.
즉, 관심사를 한 곳으로 분리해(집중해) 놓았기 때문에 해당 부분만 고치면 된다.
관심이 다른 코드가 있는 메소드에 영향을 주지 않을뿐더러, 독립적으로 존재하여 수정도 간단해졌다.

기능이 추가되거나 바뀐것은 없지만 UserDao는 이전보다 훨씬 깔끔해졌고 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 되었다.
이런 작업을 리팩토링(refactoring)이라고 한다. 
중복된 코드를 뽑아내는 기법을 리팩토링에서는 메소드 추출(Extracting Method) 기법이라고 한다.

## 리팩토링
    리펙토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.
    리팩토링을 하면 코드 내부 설계가 개선되어 코드를 이해하기 더 편해지고, 변화에 효율적으로 대응할 수 있다.
    결국 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수가 용이해지고, 견고하면서 유연한 제품을 개발할 수 있게 된다.

    리팩토링이 필요한(절실한) 코드의 특징을 나쁜냄새(bad smell)라고 부르기도 한다. 중복된 코드는 나쁜냄새 유형 중 하나이다.
    나쁜냄새가 풍기는 코드는 리팩토링 기법을 이용해 적절히 개선시켜야 한다.

    리팩토링은 개발자가 직관적으로 수행할 수 있지만, 본격적으로 적용하기 위해서는 학습과 훈련이 필요하다.
    나쁜 냄새에는 어떤 종류가 있고, 그에 따른 적절한 리팩토링 기법은 무엇이 있는지 공부하면 도움이 된다.
    (추천도서 - [리팩토링] 마틴 파울러, 켄트 백 공저)


# 1.2.3 DB 커넥션 만들기의 독립 
이번에는 변화에 대응하는게 아닌 변화를 반기는 DAO로 거듭날 변경을 해보자.

UserDao가 유저관리 기능을 인정받아 이를 납품 하게 되었다고 가정하자.
N사와 D사에 납품을 하게 되었는데, 납품 과정에서 문제가 생겼다.
두 회사가 각기 다른 종류의 DB를 사용하고 있고, 커넥션을 가져오는데 독자적인 방법을 적용하고 싶다는 것이다.
더 큰 문제는 납품한 이후에도 DB 커넥션을 가져올 방법이 종종 변경될 수 있다는 것이다.

소스코드를 전부 공개한 상태로 납품할 수도 있겠지만, UserDao의 기술력 유출 문제로 이어질 것을 우려해 납품사에 소스코드를 공개하고 싶지는 않다고 하자.
납품사에는 미리 컴파일된 바이너리 파일만 제공하고 싶다. 
이런 경우에 UserDao 소스코드를 제공해주지 않고 고객 스스로 원하는 커넥션 생성 방식을 사용해가며 UserDao를 사용할 수 있을까?

## 갑자기 드는 궁금증: 컴파일된 바이너리 파일을 다시 소스코드로 되돌리는 수는 없는가?
    되돌릴 수 있다. 이를 리버스 엔지니어링이라고 하며, 디컴파일러라는 툴도 존재한다.
    Java의 경우에는 디컴파일이 비교적 간단하고, 복원율이 높다. 왜냐하면 JVM에서 사용할 바이트코드로 변환하는 특성이 있기 때문이다.

물론 방법은 있다. 기존 UserDao를 한 단계 더 분리하면 된다. 우선 getConnection()을 추상 메소드로 만들어놓는다.
이 추상 클래스인 UserDao를 N사와 D사에 판매한다. UserDao를 구입한 회사는 각각 상속을 통해 NUserDao, DUserDao 서브 클래스를 만들것이다.
서브클래스에서는 추상메소드로 선언했던 getConnection() 을 원하는 방식으로 구현할 수 있게 되었다.

UserDao [add, get, getConnection(추상화)] ----> NUserDao [getConnection(세부구현)]
                                        ----> DUserDao [getConnection(세부구현)]

--------------------------------------------------------------------------------------------
public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        ...
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection(); 
        ...
    }

    // 추상 메소드화
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
    @Override
    public Connection getConnection throws ClassNotFoundException, SQLException {
        // N 사 DB Connection 생성 코드
    }
}

public class DUserDao extends UserDao {
    @Override
    public Connection getConnection throws ClassNotFoundException, SQLException {
        // D 사 DB Connection 생성 코드
    }
}
--------------------------------------------------------------------------------------------

DB 연결을 어떻게 할 것인가에 대한 관심사항은 서브 클래스에서 담당하고, 나머지 유저 관리 기능에 대한 관심사항은 슈퍼클래스에서 담당하고 있다.
클래스 계층 구조를 이용하여, 두 개의 관심이 독립적으로 분리되면서 변경 작업은 한 층 더 용이해졌다.

슈퍼클래스에 기본 로직의 흐름을 만들고, 
그 기능의 일부를 추상 메소드나 오버라이딩이 추상 메소드로 만들어 서브 클래스에서 필요에 맞게 구현하여 사용하는 방법을 
디자인 패턴에서는 '템플릿 메소드 패턴(Template Method Pattern)' 이라고 한다. 이는 스프링에서 애용되는 디자인 패턴이다.
(추상 메소드가 있고 이에 대한 상세 구현에 차이가 있다! --> 템플릿 메소드 패턴)

또한 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 '팩토리 메소드 패턴(Factory Method Pattern)'라 부르기도 한다.
(오브젝트의 생성 방식의 차이가 있다! --> 팩토리 메소드 패턴)

이제 add, get 함수는 Connection 이 어떻게 생성되든 고려할 필요 없이 그저 getConnection 메소드만 호출하면 된다. 

여기서는 상속구조를 통해 성격이 다른 관심사항을 분리, 서로 영향력을 줄여줌을 이해하자..

## 디자인패턴 
    디자인패턴은 소프트웨어 설계 시 특정 상황에 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.
    모든 패턴에는 간결한 이름이 있어서 잘 알려진 패턴을 적용하고자 할 때 패턴명을 언급하는것 만으로도 설계 의도와 해결책을 함께 설명할 수 있는 장점이 있다.
    디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 이를 이용해 문제를 해결한다.
    주로 클래스 상속, 오브젝트 이 두 가지 구조를 이용해 확장성을 추구한다.
    패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도이다. 이 핵심 의도가 무엇인지 파악하는게 매우 중요하다.

## 템플릿 메소드 패턴
    상속을 통해 슈퍼클래스 기능을 확장할 때 사용하는 가장 대표적인 방법이다.
    변치 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경 및 확장되는 기능은 서브클래스에 만들도록 한다.
    슈퍼클래스는 추상 메소드나 미리 오버라이딩 가능 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다.
    (슈퍼클래스에서 비워두고 서브클래스에서 선택적으로 오버라이드 할 수 있게 만들어둔 메소드를 훅(hook) 메소드라고 부른다.)
    서브클래스는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드 하는 방법을 이용해 일부 기능을 확장한다.
--------------------------------------------------------------------------------------------
public abstract class Super {
    public void templateMethod() {
        // 기본 알고리즘 코드
        hookMethod();
        abstractMethod();
        ...
    }

    protected void hookMethod() { }         // 선택적으로 오버라이딩 가능한 훅 메소드 
    public abstract void abstractMethod();  // 반드시 오버라이딩해야 하는 추상 메소드
}

public class Sub1 extends Super {   // 슈퍼클래스 메소드를 오버라이드하거나 구현해서 기능을 확장한다.
                                    // 다양한 확장 클래스를 만들 수 있다.
    @Override
    protected void hookMethod() {
        ...
    }

    @Override
    public void abstractMethod() {
        ...
    }
}
--------------------------------------------------------------------------------------------

## 팩토리 메소드 패턴
    구조나 개념은 템플릿 메소드 패턴과 동일하다.
    서브클래스는 다양한 방법으로 클래스의 오브젝트를 생성하는 메소드를 재정의할 수 있다.
    이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 
    이 방식을 이용해 오브젝트 생성 방법을 서브클래스에 맡기는 방법을 팩토리 메소드 패턴이라고 한다.

    UserDao에서 상속구조를 이용해 커넥션 생성의 관심을 서브클래스로 넘긴 경우가 팩토리 메소드 패턴의 대표적인 예라고 할 수 있다.

    UserDao --> NUserDao --> (getConnection 으로 커넥션 생성) --> AConnection --> Connection(A) 사용
            --> DUserDao --> (getConnection 으로 커넥션 생성) --> BConnection --> Connection(B) 사용


하지만 이 방법들은 상속을 사용하였다는 단점이 있다.
상속은 간단해보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다.
UserDao가 이미 다른 목적을 위해 상속을 사용하고 있다면 어떨까? (1)
JAVA는 다중 상속을 허용하고 있지 않는다.
이미 상속구조로 관심을 분리하였다면 추후 다른 목적으로 UserDao에 상속을 적용하기 힘들어진다.

또 다른 단점은 생각보다 상하위 클래스 구조가 밀접하다는 것이다. (2)
상속관계를 통해 관심을 분리하였지만, 상하위 서로 다른 관심사에 대해 긴밀한 결합을 허용한다.
(서브 클래스는 슈퍼 클래스의 기능을 직접 사용할 수 있다.)
그래서 슈퍼클래스의 변경이 생겼을때 서브클래스의 코드를 모조리 바꾸거나 다시 개발해야 할 수도 있다.
(그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 변화되지 않도록 제약을 가할 수도 있지만, 이게 과연 맞는것인가?)

확장된 기능인 DB커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다. (3)
만약 UserDao 외 DAO 클래스가 계속 만들어지면 getConnection() 구현 코드가 매 DAO 클래스마다 중복돼서 나타나는 심각한 문제가 발생할 것이다.